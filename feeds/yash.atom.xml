<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>poliastro - Yash</title><link href="https://www.poliastro.space/" rel="alternate"></link><link href="https://www.poliastro.space/feeds/yash.atom.xml" rel="self"></link><id>https://www.poliastro.space/</id><updated>2021-08-22T12:00:00+02:00</updated><subtitle>poliastro website</subtitle><entry><title>Summarizing GSoC 2021</title><link href="https://www.poliastro.space/blog/2021/08/22/conclusion-gsoc21/" rel="alternate"></link><published>2021-08-22T12:00:00+02:00</published><updated>2021-08-22T12:00:00+02:00</updated><author><name>Yash</name></author><id>tag:www.poliastro.space,2021-08-22:/blog/2021/08/22/conclusion-gsoc21/</id><summary type="html">&lt;p&gt;This page describes the work done during Google Summer of Code 2021 with &lt;a href="https://github.com/poliastro/poliastro"&gt;poliastro&lt;/a&gt;. I added some space event detectors under the &lt;code&gt;twobody&lt;/code&gt; problem by implementing raw orbital mechanics algorithms (inside &lt;code&gt;poliastro.core&lt;/code&gt;) accelerated by the &lt;code&gt;numba.jit()&lt;/code&gt; decorator (in the &lt;code&gt;nopython&lt;/code&gt; compilation mode, as was customary in &lt;code&gt;poliastro&lt;/code&gt;). It uses the &lt;code&gt;events&lt;/code&gt; parameter from &lt;code&gt;scipy.integrate.solve_ivp&lt;/code&gt; for tracking events and numerical integration. The required condition is checked at each time instance for an event occurence.&lt;/p&gt;
&lt;p&gt;The validation cases for the events were developed against the &lt;a href="https://www.orekit.org/"&gt;&lt;code&gt;orekit&lt;/code&gt;&lt;/a&gt; software, using the &lt;a href="https://gitlab.orekit.org/orekit-labs/python-wrapper"&gt;Orekit Python Wrapper&lt;/a&gt;, and some additional tests were added for investigating edge-cases. The user guide for the added events and some plotting results using &lt;code&gt;poliastro&lt;/code&gt;’s plotting capabilities, can be found &lt;a href="https://docs.poliastro.space/en/latest/examples/Detecting%20Events.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Added events (so far…)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Altitude Crossing &lt;a href="https://github.com/poliastro/poliastro/pull/1254"&gt;#1254&lt;/a&gt;.&lt;ul&gt;
&lt;li&gt;The already existing &lt;code&gt;LithobrakeEvent&lt;/code&gt; was made to inherit this event …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;This page describes the work done during Google Summer of Code 2021 with &lt;a href="https://github.com/poliastro/poliastro"&gt;poliastro&lt;/a&gt;. I added some space event detectors under the &lt;code&gt;twobody&lt;/code&gt; problem by implementing raw orbital mechanics algorithms (inside &lt;code&gt;poliastro.core&lt;/code&gt;) accelerated by the &lt;code&gt;numba.jit()&lt;/code&gt; decorator (in the &lt;code&gt;nopython&lt;/code&gt; compilation mode, as was customary in &lt;code&gt;poliastro&lt;/code&gt;). It uses the &lt;code&gt;events&lt;/code&gt; parameter from &lt;code&gt;scipy.integrate.solve_ivp&lt;/code&gt; for tracking events and numerical integration. The required condition is checked at each time instance for an event occurence.&lt;/p&gt;
&lt;p&gt;The validation cases for the events were developed against the &lt;a href="https://www.orekit.org/"&gt;&lt;code&gt;orekit&lt;/code&gt;&lt;/a&gt; software, using the &lt;a href="https://gitlab.orekit.org/orekit-labs/python-wrapper"&gt;Orekit Python Wrapper&lt;/a&gt;, and some additional tests were added for investigating edge-cases. The user guide for the added events and some plotting results using &lt;code&gt;poliastro&lt;/code&gt;’s plotting capabilities, can be found &lt;a href="https://docs.poliastro.space/en/latest/examples/Detecting%20Events.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Added events (so far…)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Altitude Crossing &lt;a href="https://github.com/poliastro/poliastro/pull/1254"&gt;#1254&lt;/a&gt;.&lt;ul&gt;
&lt;li&gt;The already existing &lt;code&gt;LithobrakeEvent&lt;/code&gt; was made to inherit this event.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Latitude Crossing &lt;a href="https://github.com/poliastro/poliastro/pull/1268"&gt;#1268&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Eclipse (penumbra and umbra) Event &lt;a href="https://github.com/poliastro/poliastro/pull/1246"&gt;#1246&lt;/a&gt;.&lt;ul&gt;
&lt;li&gt;Thanks to &lt;code&gt;numba&lt;/code&gt;'s function optimization capabilities for accelerating some calculations in the developed analytical "shadow" function!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Nodal Crossing &lt;a href="https://github.com/poliastro/poliastro/pull/1293"&gt;#1293&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These events could be used for orbits around any solar system body, and are not restricted to the Earth, since they do not leverage any earth-specific properties.&lt;/p&gt;
&lt;p&gt;The template structure to use the events is given below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;event_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Event&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;direction&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;terminal&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;event_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cowell&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;attractor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;orbit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;orbit&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;tofs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;func_twobody&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;where the argument &lt;code&gt;f&lt;/code&gt;, which defaults to keplerian-only forces, can be modified to include, for example, atmospheric perturbations for more rigorous orbit analyses.&lt;/p&gt;
&lt;h2&gt;Other work (bug fixes, additional patches)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We observed some general and events-related bugs, one of which was related to orbit propagation termination during event tracking:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Issue: &lt;a href="https://github.com/poliastro/poliastro/issues/1285"&gt;#1285&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PR: &lt;a href="https://github.com/poliastro/poliastro/pull/1288"&gt;#1288&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Some examples of additional and/or supporting patches include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Marginal newton iteration speed enhancement for eccentric and hyperbolic anomaly calculation (https://github.com/poliastro/poliastro/pull/1247).&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adding tests:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/poliastro/poliastro/pull/1255"&gt;#1255&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/poliastro/poliastro/pull/1272"&gt;#1272&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Completing work on removing some test warnings &lt;a href="https://github.com/poliastro/poliastro/pull/1235"&gt;#1235&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have also included the progress journey in the following blog posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.poliastro.space/blog/2021/06/06/poliastro-gsoc-yash/"&gt;Introduction blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.poliastro.space/blog/2021/07/19/adding-ale-event-detectors/"&gt;Second blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What is left to do?&lt;/h2&gt;
&lt;p&gt;Apart from the above, implementing some events is currently work-in-progress, on which I would continue to work:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Line-of-sight (LOS) event &lt;a href="https://github.com/poliastro/poliastro/pull/1258"&gt;#1258&lt;/a&gt;.&lt;ul&gt;
&lt;li&gt;An edge-case, when the satellite hits the attractor (&lt;code&gt;LithobrakeEvent&lt;/code&gt;) while tracking for a LOS, is under inspection.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Satellite visibility with respect to a ground station &lt;a href="https://github.com/poliastro/poliastro/pull/1299"&gt;#1299&lt;/a&gt;.&lt;ul&gt;
&lt;li&gt;Slight event time mismatches with the corresponding &lt;code&gt;orekit&lt;/code&gt;'s &lt;code&gt;ElevationDetector&lt;/code&gt; are being investigated.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Satellite view event &lt;a href="https://github.com/poliastro/poliastro/pull/1298"&gt;#1298&lt;/a&gt;.&lt;ul&gt;
&lt;li&gt;The addition of a reliable test example to check the added implementation is pending.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Satellite-satellite collision detection.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;I am very grateful to and sincerely thank my mentors, Juan Luis Cano Rodríguez and Jorge Martínez, for critically reviewing pull requests, assisting in making event API decisions, and for help in implementing the event validation cases.&lt;/p&gt;</content><category term="GSOC"></category><category term="GSOC"></category><category term="GSOC21"></category><category term="poliastro"></category></entry><entry><title>Adding the Altitude, Latitude, and Eclipse event detectors</title><link href="https://www.poliastro.space/blog/2021/07/19/adding-ale-event-detectors/" rel="alternate"></link><published>2021-07-19T12:00:00+02:00</published><updated>2021-07-19T12:00:00+02:00</updated><author><name>Yash</name></author><id>tag:www.poliastro.space,2021-07-19:/blog/2021/07/19/adding-ale-event-detectors/</id><summary type="html">&lt;p&gt;It was an engaging first half of GSoC, and it was during this duration, I understood some critical details of executing the event detectors. We started to look into the eclipse detector since we thought it might be challenging to get it right.&lt;/p&gt;
&lt;p&gt;In the weekly community calls, we brainstormed over an appropriate method that would fit in poliastro. Thanks to SciPy’s events support through &lt;code&gt;solve_ivp&lt;/code&gt;, we just had to come up with a time-varying and continuous “shadow” function without having to solve analytical equations manually. However, the critical challenge for us was to come up with such an equation! After a few trials of geometric manipulations and Jorge and Juanlu’s assistance, we came across an equation involving classical orbital elements that could serve our purpose. We were still questioning the performance and complexity of the method since …&lt;/p&gt;</summary><content type="html">&lt;p&gt;It was an engaging first half of GSoC, and it was during this duration, I understood some critical details of executing the event detectors. We started to look into the eclipse detector since we thought it might be challenging to get it right.&lt;/p&gt;
&lt;p&gt;In the weekly community calls, we brainstormed over an appropriate method that would fit in poliastro. Thanks to SciPy’s events support through &lt;code&gt;solve_ivp&lt;/code&gt;, we just had to come up with a time-varying and continuous “shadow” function without having to solve analytical equations manually. However, the critical challenge for us was to come up with such an equation! After a few trials of geometric manipulations and Jorge and Juanlu’s assistance, we came across an equation involving classical orbital elements that could serve our purpose. We were still questioning the performance and complexity of the method since by enacting it, we could lose the accuracy of entry and exit times of the event. In any case, the other approaches didn’t seem to work just yet, so we decided to go with this approach since it looked feasible. However, we figured out that the whole implementation could be jitted, thus considerably mitigating the issue.&lt;/p&gt;
&lt;p&gt;While working on the eclipse event, we worked on the altitude and latitude crossing detectors. Realizing the base structure of all the events would be the same, and the already existing &lt;code&gt;Lithobrake&lt;/code&gt; event would be a particular case of the &lt;code&gt;AltitudeCrossEvent&lt;/code&gt;, we refactored the &lt;code&gt;events&lt;/code&gt; module by removing boilerplate code to prevent redundancy. The logic of &lt;code&gt;LatitudeCrossEvent&lt;/code&gt; could get substantially shorter due to the &lt;code&gt;cartesian_to_ellipsoidal&lt;/code&gt; method, which allowed us to convert the cartesian coordinates of an orbit to its corresponding latitude on the attractor. Since we felt more intricacies in the longitude detector, we are taking some time to think about an appropriate method to solve it. All the events are supposed to work for any attractor, thus aligning with one of the poliastro’s aims of having capabilities not restricted to the Earth.&lt;/p&gt;
&lt;p&gt;Leveraging some in-built functionalities of &lt;code&gt;solve_ivp&lt;/code&gt;, users could stop integration if an event is detected or control the direction of triggering the event. Fortunately, Jorge simultaneously developed validation cases to check against the Orekit software, by which we became confident of the implementation.&lt;/p&gt;
&lt;p&gt;Additionally, adding some tests, fixing some minor bugs, and making a few improvements in computation was insightful. There are more event detectors yet to come, so looking forward to it!&lt;/p&gt;</content><category term="GSOC"></category><category term="GSOC"></category><category term="GSOC21"></category><category term="poliastro"></category></entry><entry><title>GSoC 2021, the journey begins!</title><link href="https://www.poliastro.space/blog/2021/06/06/poliastro-gsoc-yash/" rel="alternate"></link><published>2021-06-06T11:00:00+02:00</published><updated>2021-06-06T11:00:00+02:00</updated><author><name>Yash</name></author><id>tag:www.poliastro.space,2021-06-06:/blog/2021/06/06/poliastro-gsoc-yash/</id><summary type="html">&lt;h1&gt;The initial days…&lt;/h1&gt;
&lt;p&gt;Hi there! I am Yash, and I will be spending this summer with poliastro as part of GSoC 2021 to add some event detection capabilities. It was around December when I first learned about poliastro, and it gradually got me fascinated by orbital mechanics.&lt;/p&gt;
&lt;p&gt;While preparing to make my first pull request, poliastro's comprehensive documentation and tutorials came to the rescue! It was much needed for a beginner like me who had just stepped into the field of Astrodynamics. This was a period when I thoroughly enjoyed interacting with the community and learning orbital mechanics while simultaneously learning the best practices in software development.&lt;/p&gt;
&lt;h1&gt;Building up ideas and our aspirations for this summer!&lt;/h1&gt;
&lt;p&gt;After deciding to submit a proposal for the event detection project, I started brainstorming and looking for several references keeping in mind their relevance …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;The initial days…&lt;/h1&gt;
&lt;p&gt;Hi there! I am Yash, and I will be spending this summer with poliastro as part of GSoC 2021 to add some event detection capabilities. It was around December when I first learned about poliastro, and it gradually got me fascinated by orbital mechanics.&lt;/p&gt;
&lt;p&gt;While preparing to make my first pull request, poliastro's comprehensive documentation and tutorials came to the rescue! It was much needed for a beginner like me who had just stepped into the field of Astrodynamics. This was a period when I thoroughly enjoyed interacting with the community and learning orbital mechanics while simultaneously learning the best practices in software development.&lt;/p&gt;
&lt;h1&gt;Building up ideas and our aspirations for this summer!&lt;/h1&gt;
&lt;p&gt;After deciding to submit a proposal for the event detection project, I started brainstorming and looking for several references keeping in mind their relevance in poliastro. During this period, JuanLu and Jorge's suggestions proved invaluable. As a result, I came up with nine event detectors that I thought would be a good addition.&lt;/p&gt;
&lt;p&gt;There were so many things for me to explore in this field! One such topic that intrigued me and kept me tinkering with the code for several weeks was the streamlined execution of algorithms. The project that we'd be working on would require implementing several algorithms from literature, and I am super excited to be working on it! We believe these event detectors would provide users with beneficial information of scientific interest and pave the way for formulating effective space strategies and orbital design and maintenance policies.&lt;/p&gt;
&lt;p&gt;Apart from this, several discussions are going on in the community meetings regarding solving some critical issues, working on enhancements in the library, and implementing some exciting ideas to incorporate in poliastro. I also hope to contribute to it along the way…&lt;/p&gt;
&lt;p&gt;Needless to say, this is a place where I would get to interact with an engaging community and learn several things. I'm looking forward to a thrilling summer ahead, and I can't wait to start coding!&lt;/p&gt;</content><category term="GSOC"></category><category term="GSOC"></category><category term="GSOC21"></category><category term="poliastro"></category></entry></feed>